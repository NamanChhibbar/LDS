\section{Proposed Methods}
% \section{Methodology}


\subsection{Central Truncation}
\label{method:truncation}

Truncation is the most common and straightforward approach used to handle long texts
that exceed the context size of an LLM.
It is done in three main ways:

\begin{itemize}
	\item \textbf{Retaining Head}: Keeping tokens from the start.
	\item \textbf{Retaining Tail}: Keeping tokens from the end.
	\item \textbf{Head and Tail}: Keeping tokens from both start and end.
\end{itemize}

\citet{worsham-kalita-2018-genre} also employ "retaining head" and "retaining tail"
strategies on long texts and find promising results.
Though the "retaining head" method is often used, keeping the initial tokens allowed
by the LLM, \citet{sun2019fine} have found that keeping both head and tail produces
better results than both the "retaining head" and the "retaining tail" methods.
Their research also shows that truncating the middle is even better than the more
complicated hierarchical methods, displaying superiority with simplicity.


\subsection{Document Skimming}
\label{method:skimming}

One way to process long texts is by employing a speed reading strategy known as
"skimming".
Skimming is done by reading the whole text in a go while selectively skipping some
parts of the text for quicker reading.
The reader usually omits the portions that seem redundant or irrelevant in the text,
minimizing information loss.

Since we do not know which parts of a text are relevant, we suggest uniformly sampling
sentences or segments of the text such that they fit in the context size of the LLM.
This approach ensures we sample a segment from each part of the text.
This approch is a modification to the methodology \citet{wang2024videoagent} use for
QA on long videos. \citet{worsham-kalita-2018-genre} also use random sampling for genre
identification.


\subsection{Document Skimming with Extraction}

In addition to skimming, we can use keywords from an extractive summarization
algorithm to obtain similarity scores for keywords and text segments.
We can then create a probability distribution using the scores from which we can sample
text segments to include.
This will help us choose segemnts intelligently instead of randomly sampling them.

Some extractive summarization algorithms that can be used are:

\begin{itemize}
	\item \textbf{TextRank}: An unsupervised graph-based ranking algorithm developed for
	keyword and sentence extraction. It is introduced by
	\citet{mihalcea-tarau-2004-textrank}.
	\item \textbf{LexRank}: An algorithm similar to TextRank, but uses cosine similarity
	for extraction. It is developed by \citet{erkan2004lexrank}.
	\item \textbf{PacSum}: An algorithm also similar to TextRank, but also uses
	positional information for extraction. It is developed by
	\citet{zheng-lapata-2019-sentence}.
	\item \textbf{ATS using Luhn's Heuristic}: An algorithm introduced by
	\citet{siddika2022automatic} that extracts sentences based on term frequencies.
	\item \textbf{SummaRuNNer}: An RNN based sequence model for extractive summarization.
	Developed by \citet{nallapati2017summarunner}.
\end{itemize}

This approach is similar to the way \citet{golia2024action} use action-item
pairs to summarize.


\subsection{Summarization using Convolutions}

Another way to approach the problem is to apply convolution to encoded segments of
the document.
The convolution operation multiplies a sliding window of weights element-wise by the
embeddings and then sums the result.
This allows the model to learn cross-segment relationships and acts as a
limited-range attention mechanism, an algorithm similar to \citet{chen2022long}.

This method begins with separating sentences from the document and grouping them
based on a fixed maximum number of sentences per group.
These groups are then encoded and passed through a 1D convolution layer of size $k$ with
$f$ filters, where $k$ and $f$ are hyperparameters in the model.
A max-pooling layer can also be applied for feature enhancement.
A decoder-only transformer then uses these processed embeddings as keys and values
for the encoder-decoder attention mechanism to generate the summary.

Longformer model \cite{beltagy2020longformer} uses a windowed attention mechanism with
linear complexity to process long texts.
Our 1D convolution operation outperforms the windowed attention mechanism since it has
linear complexity and is more efficient to calculate than attention.



\section{Implemented Pipelines}


\subsection*{Pipeline 1}

This pipeline is based on the Truncation method proposed in Section \ref{method:truncation}
and truncates the middle of the text.
It includes a hyperparameter $head\_size \in [0, 1]$ which determines the fraction of tokens
to be taken from the head.
Setting $head\_size = 1$ results in taking tokens only from the head, whereas
setting $head\_size = 0$ results in taking tokens only from the tail.
The truncated text is then sent to the summarizer.


\subsection*{Pipeline 2}

This pipeline is based on the Document Skimming method proposed in Section \ref{method:skimming}
and uniformly samples segments of the text.
This method starts by segmenting the text using a segmenter.
It inlcudes a hyperparameter $min\_words$, which controls the minimum number of words required
in a segment.
The segmenter uses a sentence tokenizer to separate sentences from the text, and then
merges the sentences which have fewer words than $min\_words$.
We then sample segments uniformly, with each segment having probability $p$ to be picked.
The sampled segments are then merged to form a single text and sent to the summarizer.
The calculation for the optimal value of $p$ is given below:

Let $X$ be denote the total number of tokens in the picked segments.
Since segments are picked randomly, $X$ is a random variable.
If the context size of the model is $c$, we want $\mathrm{E}[X] = c$, where $\mathrm{E}[X]$
denotes the expectation of $X$.

Suppose we have $n \in \mathbb{N}$ segments and $X_i \sim \mathrm{Bernoulli}(p)$ denotes
if segment $i$ is chosen, $i \in \{1, 2, \dots, n\}$.
If $len_i$ denotes the number of tokens in segment $i$, we can write:

\[ X = \sum_{i = 1}^{n} X_i \cdot len_i \]
\[ \Rightarrow \mathrm{E}[X] = \mathrm{E}[\sum_{i = 1}^{n} X_i \cdot len_i] \]
\[ \Rightarrow \mathrm{E}[X] = \sum_{i = 1}^{n} \mathrm{E}[X_i \cdot len_i] \]
\[ \Rightarrow \mathrm{E}[X] = \sum_{i = 1}^{n} \mathrm{E}[X_i] \cdot len_i \]

Since $X_i \sim \mathrm{Bernoulli}(p)$ $\forall i \in \{1, 2, \dots, n\}$, we
have $\mathrm{E}[X_i] = p$ $\forall i \in \{1, 2, \dots, n\}$.

\[ \Rightarrow \mathrm{E}[X] = \sum_{i = 1}^{n} p \cdot len_i \]
\[ \Rightarrow \mathrm{E}[X] = p \cdot \sum_{i = 1}^{n} len_i \]

Let $total\_len$ be the total number of tokens in the text, then
$total\_len = \sum_{i = 1}^{n} len_i$.

\[ \therefore \mathrm{E}[X] = p \cdot total\_len \]
\[ \mathrm{E}[X] = c \Rightarrow p \cdot total\_len = c \]
\[ \therefore p = c / total\_len \]


\subsection*{Pipeline 3}

This pipeline is a modification of \textbf{Pipeline 2}.
After sampling the segments, segments similar to previously selected segments are removed
by comparing the segment embeddings generated by a
\href{https://huggingface.co/sentence-transformers/all-MiniLM-L6-v2}{sentence transformer},
which is based on MiniLM \cite{wang2020minilm}.

This includes iterating linearly over the sampled segment and tracking the mean of the segment
embeddings, denoted by $mean\_emb$.
We use cosine similarity to compare $mean\_emb$ to the current segment embedding,
denoted as $emb_i$, where $i$ is the index of the current segment.
If \[ \mathrm{cos\_sim}(mean\_emb, emb_i) \ge threshold \]
where $threshold$ is a hyperparameter, then segment $i$ is removed.
The filtered segments are then concatenated and sent to the summarizer.


\subsection*{Pipeline 4}

This pipeline is also a modification of \textbf{Pipeline 2} and is similar to
\textbf{Pipeline 3}.
Instead of removing similar segments after sampling the segments, we first remove similar
segments and then uniformly sample the segments.
Although this pipeline is slower than \textbf{Pipeline 3}, it ensures better utilization of
the LLM's context size.
Similar to \textbf{Pipeline 3}, it includes a hyperparameter $threshold$, which controls
how similar a segment should be to remove it.
After removal of segments and sampling, the segments are concatenated and sent to the
summarizer.
